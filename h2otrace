#!python
# usage: h2otrace PID

from __future__ import print_function
import re, ctypes, sys, json, binascii, os, time
from multiprocessing import Queue, Process
from collections import OrderedDict
from itertools import izip_longest
from bcc import USDT, BPF, get_online_cpus

# os.nice(-1) # to give it a little bit more CPU

def slurp(path):
    with open(path, "r") as f:
        return f.read()

d = slurp("./quicly-probes.d")

block_fields = {
    "quicly:crypto_decrypt": set(["decrypted"]),
    "quicly:receive": set(["bytes"]),
    "quicly:crypto_update_secret": set(["secret"]),
    "quicly:crypto_send_key_update": set(["secret"]),
    "quicly:crypto_receive_key_update": set(["secret"]),
    "quicly:crypto_receive_key_update_prepare": set(["secret"]),
}

block_probes = set([
    "quicly:debug_message",
    "quicly:free",
])

# mapping from proves.d's to quic-trace's:
rename_map = {
    "at": "time",
    "master_id": "master_conn_id",
}

whitespace = r'(?:/\*.*?\*/|\s+)'
probe_decl = r'(?:\bprobe\s+(?:[a-zA-Z0-9_]+)\s*\([^\)]*\)\s*;)'
d_decl = r'(?:\bprovider\s*(?P<provider>[a-zA-Z0-9_]+)\s*\{(?P<probes>(?:%s|%s)*)\})' % (probe_decl, whitespace)

re_flags = re.X | re.M | re.S

matched = re.search(d_decl, d, flags = re_flags)
provider = matched.group('provider')

struct_def = r"""
// Fields that include "dummy" are ignored

struct st_quicly_stream_t {
    u64 dummy;
    s64 stream_id;
};

struct st_quicly_conn_t {
    u32 dummy[4];
    u32 master_id;
};

struct st_h2o_conn_t {
    void *dummy_ctx;
    void **dummy_hosts;
    u64 dummy_connected_at[2];
    u64 h2o_conn_id;
};

struct quicly_rtt_t {
    u32 minimum;
    u32 smoothed;
    u32 variance;
    u32 latest;
};

struct st_quicly_address_token_plaintext_t {
    int dummy;
};
"""

def strip_typename(t):
    return t.replace("*", "").replace("struct", "").replace("const", "").replace("strict", "").strip()

def is_str_type(t):
    return re.search(r'\b(?:char|u?int8_t|void)\s*\*', t)

def is_ptr_type(t):
    return "*" in t

def is_bin_type(t):
    return re.search(r'\b(?:u?int8_t|void)\s*\*', t)

def build_tracer_name(provider, metadata):
    return "trace_%s__%s" % (provider, metadata['probe'])

def build_tracer(provider, metadata):
    c = r"""
int %s(struct pt_regs *ctx) {
    void *buf = NULL;
    struct event_t event = { .id = %d };

""" % (build_tracer_name(provider, metadata), metadata['id'])

    block_field_set = block_fields.get(metadata["fully_specified_probe_name"], set())

    i = 0
    args = metadata['args']
    str_i = 0
    int_i = 0
    while i < len(args):
        arg = args[i]
        arg_name = arg['name']
        arg_type = arg['type']
        assert 'size' in arg
        arg_size = arg['size']
        c += "    // %s %s: %d\n" % (arg_type, arg_name, arg_size)
        if arg_name in block_field_set:
            c += "    // (ignored because it's in the block list)\n"
            i += 1
            continue

        if is_str_type(arg_type):
            c += "    bpf_usdt_readarg(%d, ctx, &buf);\n" % (i+1)
            # Use `sizeof(buf)` instead of a length variable, because older kernels
            # do not accept a variable for `bpf_probe_read()`'s length parameter.
            c += "    bpf_probe_read(&event.s%d, sizeof(event.s%d), buf);\n" % (str_i, str_i)
            str_i += 1
        elif is_ptr_type(arg_type):
            c += "    %s %s = {};\n" % (arg_type.replace("*", ""), arg_name)
            c += "    bpf_usdt_readarg(%d, ctx, &buf);\n" % (i+1)
            c += "    bpf_probe_read(&%s, sizeof(%s), buf);\n" % (arg_name, arg_name)
            st_name = strip_typename(arg_type)
            for st_key, st_valtype in st_map[st_name].items():
                c += "    event.i%d = %s.%s; /* %s */\n" % (int_i, arg_name, st_key, st_valtype)
                int_i += 1
        else:
            c += "    bpf_usdt_readarg(%d, ctx, &event.i%d);\n" % (i+1, int_i)
            int_i += 1
        i += 1
    diff = ""
    if str_i > 0:
        diff = " - %d" % (str_i * 32)
    c += """
    if (events.perf_submit(ctx, &event, sizeof(event)%s) != 0)
        bpf_trace_printk("failed to perf_submit\\n");

    return 0;
}\n""" % diff
    return c


st_map = {}
for (st_name, content) in re.findall(r'struct\s+([a-zA-Z0-9_]+)\s*\{([^}]*)\}', struct_def, flags = re_flags):
    st = st_map[st_name] = {}
    for (ctype, name, is_array) in re.findall(r'(\w+[^;]*[\w\*])\s+([a-zA-Z0-9_]+)(\[\d+\])?;', content, flags = re_flags):
        if "dummy" in name:
            continue
        st[name] = ctype + is_array

probe_metadata = {}
probe_id2metadata = {}
max_ints = 0
max_strs = 0

id = 0
for (name, args) in re.findall(r'\bprobe\s+([a-zA-Z0-9_]+)\(([^\)]+)\);', matched.group('probes'), flags = re_flags):
    arg_list = re.split(r'\s*,\s*', args, flags = re_flags)
    id += 1
    metadata = {
        "id": id,
        "probe": name,
        "fully_specified_probe_name": "%s:%s" % (provider, name),
    }
    probe_id2metadata[id] = metadata
    probe_metadata[name] = metadata
    args = metadata['args'] = map(
        lambda arg: re.match(r'(?P<type>\w[^;]*[^;\s])\s*\b(?P<name>[a-zA-Z0-9_]+)', arg, flags = re_flags).groupdict(),
        arg_list)

    # args map is a flat arg list
    args_map = metadata['args_map'] = OrderedDict()

    n_ints = 0
    n_strs = 0
    for arg in args:
        if is_str_type(arg['type']):
            args_map["s%d" % n_strs] = (arg['name'], is_bin_type(arg['type']))
            n_strs += 1
        elif is_ptr_type(arg['type']):
            # it assumes that all the fields in the struct are values (i.e. integers)
            for st_key in st_map[strip_typename(arg['type'])]:
                args_map["i%d" % n_ints] = (st_key, False)
                n_ints += 1
        else:
            args_map["i%d" % n_ints] = (arg['name'], False)
            n_ints += 1

    if max_ints < n_ints:
        max_ints = n_ints
    if max_strs < n_strs:
        max_strs = n_strs

bpf = r"""
struct event_t {
    u8 id;

"""

for i in xrange(max_ints):
    bpf += "    u64 i%d;\n" % i
for i in xrange(max_strs):
    bpf += "    char s%d[32];\n" % i

bpf += r"""
};

BPF_PERF_OUTPUT(events);

""" + struct_def


u = USDT(pid = int(sys.argv[1]))
for probe in u.enumerate_probes():
    if probe.provider != provider:
        continue

    metadata = probe_metadata[probe.name]

    if metadata["fully_specified_probe_name"] in block_probes:
        continue

    args = metadata['args']
    for i in range(0, probe.num_locations):
        location = probe.get_location(i)
        for j in range(0, location.num_arguments):
            arg = location.get_argument(j)
            args[j]['signed'] = arg.size < 0
            args[j]['size'] = abs(arg.size)
    bpf += build_tracer(provider, metadata)
    u.enable_probe(probe.name, build_tracer_name(provider, metadata))

if __debug__:
    print(bpf, file = sys.stderr)

b = BPF(text=bpf, usdt_contexts=[u], cflags=[])
print("start to trace!", file = sys.stderr)

json_encoder = json.JSONEncoder(
    separators = (',', ':'),
    allow_nan = False,
    check_circular = False
)

out = sys.stdout

def write_json_pair(name, value):
    global out
    out.write(',"') # a following comma!
    out.write(name)
    out.write('":')
    if isinstance(value, (int, long)):
        out.write(str(value))
    else:
        for part in json_encoder.iterencode(value):
            out.write(part)

# multiprocessing.Value is not available on some environments
def handle_quic_event(cpu, data, size):
    try:
        ev = b["events"].event(data)
        metadata = probe_id2metadata[ev.id]
        name = metadata["probe"]

        out.write("{")
        out.write('"type":"')
        out.write(name)
        out.write('"')

        block_field_set = block_fields.get(metadata["fully_specified_probe_name"], None)

        args_map = metadata['args_map']
        for event_t_name in args_map:
            (probe_field_name, is_bin) = args_map[event_t_name]
            if block_field_set and probe_field_name in block_field_set:
                continue
            data_field_name = rename_map.get(probe_field_name, probe_field_name)
            value = getattr(ev, event_t_name)
            if is_bin:
                value = binascii.hexlify(value)
            write_json_pair(data_field_name, value)
        out.write("}\n")
    except Exception as e:
        print(e, file = sys.stderr)
        if isinstance(e, KeyboardInterrupt):
            sys.exit(0)
        else:
            sys.exit(1)


def do_work(cpus):
    # we have to use a private method for CPU pinning
    for cpu in cpus:
        def lost_cb(lost):
            print("Possibly lost %d data ($$=%d, cpu=%d)" % (lost, os.getpid(), cpu), file = sys.stderr)
        b["events"]._open_perf_buffer(cpu, handle_quic_event, page_cnt=256, lost_cb = lost_cb)
    try:
        while True:
            b.perf_buffer_poll()
            out.flush()
    except KeyboardInterrupt:
        sys.exit()

def grouper(n, iterable, fillvalue=None):
    args = [iter(iterable)] * n
    return izip_longest(fillvalue=fillvalue, *args)

processes = []
for cpus in grouper(8, get_online_cpus()):
    p = Process(target = do_work, args = (cpus,))
    p.start()
    processes.append(p)

for p in processes:
    p.join()

# t0 = time.time()
# while True:
#     time.sleep(1)

#     t1 = time.time()
#     d = t1 - t0
#     count = 0
#     while nops.get(block = False):
#         count += 1
#     sys.stderr.write("%10d op/s\n" % (nops.count / d))
#     t0 = time.time()


